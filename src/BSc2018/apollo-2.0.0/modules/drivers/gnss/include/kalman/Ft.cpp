//
// Academic License - for use in teaching, academic research, and meeting
// course requirements at degree granting institutions only.  Not for
// government, commercial, or other organizational use.
// File: Ft.cpp
//
// MATLAB Coder version            : 3.3
// C/C++ source code generated on  : 10-Apr-2018 14:45:54
//

// Include Files
#include "rt_nonfinite.h"
#include "messure_update.h"
#include "messure_update_g.h"
#include "q2euler.h"
#include "time_update.h"
#include "Ft.h"

// Function Definitions

//
// Arguments    : double T
//                const double acc[3]
//                const double gyr[3]
//                const double q[4]
//                double v
//                double F[64]
// Return Type  : void
//
void Ft(double T, const double acc[3], const double gyr[3], const double q[4],
        double v, double F[64])
{
  double t2;
  double t5;
  double t11;
  double t17;
  double t18;
  double t21;
  double t22;
  double t23;
  double t24;
  double t37;
  double t38;
  double t41;
  double t39;
  double t40;
  double t44;
  double dv0[64];
  int i1;

  // FT
  //     F = FT(T,AY,GX,GY,GZ,Q0,Q1,Q2,Q3,V)
  //     This function was generated by the Symbolic Math Toolbox version 7.2.
  //     24-Mar-2018 02:25:46
  t2 = T * T;
  t5 = q[0] * q[3] * 2.0 - q[1] * q[2] * 2.0;
  t11 = (-acc[1] + q[1] * q[0] * 19.62) + q[2] * q[3] * 19.62;
  t17 = (q[0] * q[0] * 2.0 + q[2] * q[2] * 2.0) - 1.0;
  t18 = T * q[1] * v * 2.0;
  t21 = q[0] * q[1] * 2.0 + q[2] * q[3] * 2.0;
  t22 = q[0] * t2 * t11;
  t23 = q[3] * t2 * t11;
  t24 = T * q[2] * v * 2.0;
  t37 = std::abs(T * gyr[0]);
  t38 = std::abs(T * gyr[1]);
  t41 = std::abs(T * gyr[2]);
  t37 = (t37 * t37 * 0.25 + t38 * t38 * 0.25) + t41 * t41 * 0.25;
  t38 = std::sqrt(t37);
  t39 = std::sin(t38);
  t40 = 1.0 / std::sqrt(t37);
  t41 = std::cos(t38);
  t37 = T * gyr[2] * t39 * t40 * 0.5;
  t38 = T * gyr[0] * t39 * t40 * 0.5;
  t44 = T * gyr[1] * t39 * t40 * 0.5;
  dv0[0] = 1.0;
  memset(&dv0[1], 0, sizeof(double) << 3);
  dv0[9] = 1.0;
  memset(&dv0[10], 0, sizeof(double) << 3);
  dv0[18] = 1.0;
  dv0[19] = 0.0;
  dv0[20] = 0.0;
  dv0[21] = 0.0;
  dv0[22] = 0.0;
  dv0[23] = 0.0;
  dv0[24] = -T * t5;
  dv0[25] = T * t17;
  dv0[26] = T * t21;
  dv0[27] = 1.0;
  dv0[28] = 0.0;
  dv0[29] = 0.0;
  dv0[30] = 0.0;
  dv0[31] = 0.0;
  dv0[32] = (t23 - T * q[3] * v * 2.0) + t2 * q[1] * t5 * 9.81;
  dv0[33] = (T * q[0] * v * 4.0 - q[0] * t2 * t11 * 2.0) - t2 * q[1] * t17 *
    9.81;
  dv0[34] = (t18 - q[1] * t2 * t11) - t2 * q[1] * t21 * 9.81;
  dv0[35] = T * q[1] * -19.62;
  dv0[36] = t41;
  dv0[37] = t38;
  dv0[38] = t44;
  dv0[39] = t37;
  dv0[40] = (t24 - q[2] * t2 * t11) + t2 * t5 * q[0] * 9.81;
  dv0[41] = t2 * q[0] * t17 * -9.81;
  dv0[42] = (-t22 + T * q[0] * v * 2.0) - t2 * q[0] * t21 * 9.81;
  dv0[43] = T * q[0] * -19.62;
  dv0[44] = T * gyr[0] * t39 * t40 * -0.5;
  dv0[45] = t41;
  dv0[46] = -t37;
  dv0[47] = t44;
  dv0[48] = (t18 - q[1] * t2 * t11) + t2 * t5 * q[3] * 9.81;
  dv0[49] = (T * q[2] * v * 4.0 - q[2] * t2 * t11 * 2.0) - t2 * q[3] * t17 *
    9.81;
  dv0[50] = (-t23 + T * q[3] * v * 2.0) - t2 * q[3] * t21 * 9.81;
  dv0[51] = T * q[3] * -19.62;
  dv0[52] = T * gyr[1] * t39 * t40 * -0.5;
  dv0[53] = t37;
  dv0[54] = t41;
  dv0[55] = -t38;
  dv0[56] = (t22 - T * q[0] * v * 2.0) + t2 * t5 * q[2] * 9.81;
  dv0[57] = t2 * q[2] * t17 * -9.81;
  dv0[58] = (t24 - q[2] * t2 * t11) - t2 * q[2] * t21 * 9.81;
  dv0[59] = T * q[2] * -19.62;
  dv0[60] = T * gyr[2] * t39 * t40 * -0.5;
  dv0[61] = T * gyr[1] * t39 * t40 * -0.5;
  dv0[62] = t38;
  dv0[63] = t41;
  for (i1 = 0; i1 < 8; i1++) {
    memcpy(&F[i1 << 3], &dv0[i1 << 3], sizeof(double) << 3);
  }
}

//
// File trailer for Ft.cpp
//
// [EOF]
//
